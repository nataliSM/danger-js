"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var stripANSI = require("strip-ansi");
function jest(config) {
    if (config === void 0) { config = {}; }
    var _a = config.testResultsJsonPath, testResultsJsonPath = _a === void 0 ? 'test-results.json' : _a;
    try {
        var jsonFileContents = fs.readFileSync(testResultsJsonPath, 'utf8');
        var jsonResults = JSON.parse(jsonFileContents);
        // console.log(jsonResults)
        if (jsonResults.success) {
            // tslint:disable-next-line:no-console
            console.log('Jest tests passed :+1:');
            return;
        }
        // console.log(1)
        var isModernFormatResults = jsonResults.testResults[0].testResults;
        if (isModernFormatResults) {
            presentErrorsForNewStyleResults(jsonResults);
        }
        else {
            presentErrorsForOldStyleResults(jsonResults);
        }
    }
    catch (e) {
        // tslint:disable-next-line:no-console
        console.error(e);
        fail('[danger-plugin-jest] Could not read test results. Danger cannot pass or fail the build.');
    }
}
exports.default = jest;
var presentErrorsForOldStyleResults = function (jsonResults) {
    var failing = jsonResults.testResults.filter(function (tr) { return tr.status === 'failed'; });
    failing.forEach(function (results) {
        var relativeFilePath = path.relative(process.cwd(), results.name);
        var failedAssertions = results.assertionResults.filter(function (r) { return r.status === 'failed'; });
        var failMessage = fileToFailString(relativeFilePath, failedAssertions);
        fail(failMessage);
    });
};
var presentErrorsForNewStyleResults = function (jsonResults) {
    var failing = jsonResults.testResults.filter(function (tr) { return tr.numFailingTests > 0; });
    failing.forEach(function (results) {
        var relativeFilePath = path.relative(process.cwd(), results.testFilePath);
        var failedAssertions = results.testResults.filter(function (r) { return r.status === 'failed'; });
        var failMessage = fileToFailString(relativeFilePath, failedAssertions);
        fail(failMessage);
    });
};
// e.g. https://github.com/orta/danger-plugin-jest/blob/master/src/__tests__/fails.test.ts
var linkToTest = function (file, msg, title) {
    var line = lineOfError(msg, file);
    var repo = danger.github.pr.head.repo;
    var urlParts = [
        'https://github.com',
        repo.full_name,
        'blob',
        danger.github.pr.head.ref,
        "" + file + ('line' ? '#L' + line : ''),
    ];
    return "<a href='" + urlParts.join('/') + "'>" + title + "</a>";
};
var assertionFailString = function (file, status) { return "\n<li>\n" + linkToTest(file, status.failureMessages && status.failureMessages[0], status.title) + "\n<br/>\n" + sanitizeShortErrorMessage(status.failureMessages && stripANSI(status.failureMessages[0])) + "\n\n<details>\n<summary>Full message</summary>\n<pre><code>\n" + (status.failureMessages && stripANSI(status.failureMessages.join('\n'))) + "\n</code></pre>\n</details>\n</li>\n<br/>\n"; };
var fileToFailString = function (path, failedAssertions) { return "\n<b>\uD83C\uDCCF FAIL</b> in " + danger.github.utils.fileLinks([path]) + "\n\n" + failedAssertions.map(function (a) { return assertionFailString(path, a); }).join('\n\n') + "\n"; };
var lineOfError = function (msg, filePath) {
    var filename = path.basename(filePath);
    var restOfTrace = msg.split(filename, 2)[1];
    return restOfTrace ? parseInt(restOfTrace.split(':')[1], 10) : null;
};
var sanitizeShortErrorMessage = function (msg) {
    if (msg.includes('does not match stored snapshot')) {
        return 'Snapshot has changed';
    }
    return msg
        .split('   at', 1)[0]
        .trim()
        .split('\n')
        .splice(2)
        .join('')
        .replace(/\s\s+/g, ' ')
        .replace('Received:', ', received:')
        .replace('., received', ', received')
        .split('Difference:')[0];
};
